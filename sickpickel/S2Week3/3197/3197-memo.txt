이 문제에서는 매일 얼음이 녹고 난 후 각 백조의 처음 위치에서 탐색을 시작하는 일반적인 BFS로는 시간제한을 넘김으로, 이전에 탐색과정에서 끊겼던 부분들을 저장해두었다가 이번 탐색의 시작점으로 사용하는 최적화가 필요하다. (이진탐색으로 푸는 방식에선 이 최적화가 굳이 필요하지 않은 듯 하다.) 

 다만 이 최적화의 과정에서 같은 위치를 중복 방문하는 과정을 생략하기 위해서 사용하는 visited 배열의 처리가 까다롭다. 양 백조 모두 서로를 찾거나, 유니온 파인드로 얼음을 녹여가면서 이동했을 때 두 백조가 같은 집합에 속하는지 확인하는 형태로 구현한다면 백조가 서로를 만날 수 있는지 검사하는 위치가 곧 반대쪽에서 이미 이동한 위치 즉, visited == true 인 위치임으로 if(visited) continue; 문보다 백조가 만날 수 있는 경로인지를 먼저 검사하여야 한다. (그렇게함으로써 큐에 다음위치 추가문장과 도달가능 검사문장은 당연히 분리되어야한다.) 
 
 추가로 주의할 점은 이번 턴에서 탐색할 위치, 다음 턴에서 시작할 위치의 2개의 큐로 나누어 넣을 때 둘 중 하나라도 visited처리를 안해주면 메모리초과가 난다. (다음 턴에서 시작할 위치 큐(nextQueue)에 대해서는 visited 처리를 안해주어도 답을 구하는데는 문제가 없지만, 중복되는 값들이 큐에 너무 많이 들어가 메모리초과를 유발한다.)